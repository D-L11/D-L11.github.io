<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>typescript高级特性-泛型</title>
    <link href="/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h2><p>使用泛型最大的用处在于，它可以用来定义程序中各个成员互相之间的类型约束。这些成员可以是类的实例，可以是类的方法，函数参数或者函数的返回值等等</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是一个stack类</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>    <span class="hljs-keyword">private</span> data = []<br>    push = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item)<br>    pop = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>()<br>&#125;<br><span class="hljs-keyword">const</span> stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>()<br><br>stk.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">//1</span><br><br>stk.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>假如，由多个开发者，分别写了1和2处的代码，隐患就在这时悄悄地产生了。比如另外一位开发者写了这样的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">stk.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">toUpperCase</span>() <span class="hljs-comment">//运行时错误</span><br></code></pre></td></tr></table></figure><p>上面的代码会抛出一个运行时错误。这些问题产生的根本原因，是我们没有对Stack类做任何的类型约束，那么下面就加一个类型约束看看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>    <span class="hljs-keyword">private</span> data = []<br>    push = <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item)<br>    pop = (): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>()<br>&#125;<br><span class="hljs-keyword">const</span> stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>()<br>stk.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//编译时错误</span><br></code></pre></td></tr></table></figure><p>我们将data中的数据类型严格限制为字符串类型，这样就不会出现第一个代码示例中的错误。但是如果我还需要一个栈来存放数值类型的值应该怎么办呢？重新实现一个NumberStack类么？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberStack</span> &#123;<br>    <span class="hljs-keyword">private</span> data = []<br>    push = <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item)<br>    pop = (): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>()<br>&#125;<br><span class="hljs-keyword">const</span> numStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberStack</span>()<br>numStk.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>) <br></code></pre></td></tr></table></figure><p>大家可以看出来这样做是很多余的，我需要保存几种数据类型的值，就需要去实现几个Stack，代码变得又臭又长。这时候泛型就可以出场了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> data = []<br>    push = <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item)<br>    pop = (): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>()<br>&#125;<br><br><span class="hljs-keyword">const</span> numStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">number</span>&gt;()<br><span class="hljs-keyword">const</span> stringStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">string</span>&gt;()<br>numStk.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>stringStk.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以注意一下写法，我们在定义Stack类时，传入了一个泛型参数T，之后在向data添加数据的时候规定了只能够传入T数据类型。这时候类型之间的制约关系就形成了，我们只需要在实例化Stack时给T传参即可。</p><p>再看一个例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> pop&lt;T&gt; (<span class="hljs-attr">arr</span>: T[]): T &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">pop</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，类型约束产生在函数调用参数和函数返回值之间。比如给一个保存了数值类型的数组作为参数，则函数必须返回数值类型的值</p><h2 id="什么时候需要泛型"><a href="#什么时候需要泛型" class="headerlink" title="什么时候需要泛型"></a>什么时候需要泛型</h2><p>你想要描述一个什么样的约束？如果不能较快地回答出这个问题，那这个泛型很可能是无用的。看以下代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> func&lt;T&gt; (<span class="hljs-attr">item</span>: <span class="hljs-built_in">string</span>): T<br></code></pre></td></tr></table></figure><p>上面地函数声明中，T只用在了一处，它没有与其他任何数据产生关联，自然也就没有产生任何约束，这就是一个无用的泛型。</p><p>希望对大家有所帮助，有不对的地方欢迎大佬们指正。</p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3.0响应式原理简介</title>
    <link href="/2022/02/23/Vue3-0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/02/23/Vue3-0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>在Vue2.X中，是利用Object.defineProperty()方法来侦测对象的变化。但这种方法有以下几种缺陷<br/><br><strong>1) 无法侦测删除属性或新增属性</strong><br/><br><strong>2) 改变数组的length属性无法被侦测</strong><br/><br><strong>3) 性能较差</strong><br/></p><p>而Vue3.0中则使用了es6的<strong>Proxy</strong>来进行变化侦测。Proxy相比于Object.defineProperty()方法来讲性能更优异。数组的变化也可以直接get()和set()方法，不需要像Vue2.X那样单独处理数组的变化侦测。<strong>Proxy称为代理，他为javascript提供了元编程的能力，是一种可以直接拦截并改变底层javascript引擎操作的包装器。</strong></p><p>对es6不太了解的朋友推荐阅读阮一峰的es6标准入门</p><p>下面是一个创建代理的简单示例</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-comment">//陷阱函数，读取target属性值时触发</span><br>    <span class="hljs-comment">//三个参数分别是目标对象，读取的属性名，proxy对象本身</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;property&#125;</span>属性已被读取`</span>)<br>        <span class="hljs-keyword">return</span> target[property]<br>    &#125;,<br>    <span class="hljs-comment">//改变属性值时触发</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;property&#125;</span>属性已被设置为<span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>        target[property] = value<br>        <span class="hljs-keyword">return</span> value<br>    &#125;,<br>     <span class="hljs-comment">//删除属性时触发</span><br>    deleteProperty (target, property) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;property&#125;</span>属性已被删除`</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> name = proxy.<span class="hljs-property">name</span> <span class="hljs-comment">//name属性已被读取</span><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">//name属性已被设置为bar</span><br><span class="hljs-keyword">delete</span> proxy.<span class="hljs-property">name</span> <span class="hljs-comment">//name属性已被删除</span><br></code></pre></td></tr></table></figure><p>上面是使用Proxy侦测对象变化的简单示例，下面让我们来模拟实现一下Vue3.0的响应式系统</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//判断某个变量是否是对象的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span> (val) &#123;<br>    <span class="hljs-keyword">return</span> val !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//创建响应式对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span> (target) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactiveObject</span>(target)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span> (target) &#123;<br>    <span class="hljs-comment">//如果不是对象则直接返回</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br>    <span class="hljs-keyword">const</span> baseHandler = &#123;<br>        get (target, property, receiver) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取值&#x27;</span>)<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver)<br>            <span class="hljs-comment">//递归地解析嵌套对象，解决多层对象嵌套问题</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObject</span>(result) ? <span class="hljs-title function_">reactive</span>(result) : result<br>        &#125;,<br>        set (target, property, value, receiver) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置值&#x27;</span>)<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value, receiver)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;,<br>        deleteProperty (target, property) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除值&#x27;</span>)<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, property)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> observed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, baseHandler)<br>    <span class="hljs-keyword">return</span> observed<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;)<br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">//设置值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>)<span class="hljs-comment">//读取值，bar</span><br></code></pre></td></tr></table></figure><p>看过之前的例子，上面的代码应该很容易理解。在创建响应式对象的reactive函数中，我们只需要对传入的target对象进行一次包装，返回包装后的Proxy对象就可以。之后我们就可以在Proxy对象的陷阱函数里面侦测变化。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3.0组合API</title>
    <link href="/2022/02/23/Vue3-0%E7%BB%84%E5%90%88API/"/>
    <url>/2022/02/23/Vue3-0%E7%BB%84%E5%90%88API/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要引入组合API"><a href="#为什么要引入组合API" class="headerlink" title="为什么要引入组合API"></a>为什么要引入组合API</h2><p>随着vue开始得到越来越多的开发人员的认可，使用其组建的大型项目也越来越多。但是在大型项目的开发和维护过程中遇到了一些问题。主要有以下两个</p><h3 id="1）代码难以理解"><a href="#1）代码难以理解" class="headerlink" title="1）代码难以理解"></a>1）代码难以理解</h3><p>因为vue2.x中的API强制我们按选项组织代码，实现某个逻辑的代码可能会被拆分到好几个选项中。</p><h3 id="2-体取各个组件之间重用逻辑困难"><a href="#2-体取各个组件之间重用逻辑困难" class="headerlink" title="2)体取各个组件之间重用逻辑困难"></a>2)体取各个组件之间重用逻辑困难</h3><p>因为vue3.0引入了组合API，可以将代码编写为函数，每个函数处理某个特定的功能，不需要按选项组织代码。这也使得组件之间提取和重用逻辑变得简单。</p><p><em><strong>注意：组合API在data,computed,methods等等选项之前解析，所以不能在其内部访问这些选项</strong></em></p><h1 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup()函数"></a>setup()函数</h1><p>setup函数是组合API的入口，它在prop解析之后，beforeCreate运行之前被调用。</p><h3 id="setup函数的参数"><a href="#setup函数的参数" class="headerlink" title="setup函数的参数"></a>setup函数的参数</h3><p>setup函数可以接受两个可选参数，第一个参数是props，请看以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs vue">app.component(&#x27;compo&#x27;, &#123;<br>    props: [&#x27;name&#x27;],<br>    setup(props) &#123;<br>        console.log(props.name)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>props是响应式的，也就是说我们可以在watchEffect或者watch选项中执行副作用，但是值得注意的一点是不能去解构props，否则会失去响应性，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">app.component(&#x27;compo&#x27;, &#123;<br>    props: [&#x27;name&#x27;],<br>    setup(&#123;name&#125;) &#123;<br>        Vue.watchEffect(() =&gt; &#123;<br>            console.log(name) //不再是响应式的<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>setup函数第二个参数是一个context对象，它是一个普通的javascript对象，可以用它来访问三个组件属性，分别是组件属性context.attrs，插槽context.slots和发出的事件context.emit。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">setup(props, context) &#123;<br>    console.log(context.attrs)<br>    console.log(context.slots)<br>    console.log(context.emit)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为context只是一个普通的context对象，所以可以对其进行结构</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript高级特性-枚举</title>
    <link href="/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%9E%9A%E4%B8%BE/"/>
    <url>/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h2><p>枚举是集中管理一组有关联的变量的方法，很多编程语言都提供了enum数据类型，但是javascript却没有。typescript弥补了这一点。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>先看一个简单的例子</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    white,<br>    black,<br>    blue,<br>    green<br>&#125;<br><span class="hljs-keyword">const</span> currectColor = <span class="hljs-title class_">Color</span>.<span class="hljs-property">white</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(currectColor) <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>上方的代码中，currentColor会输出0。为什么呢？我们来看看输出的js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Color</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) &#123;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;white&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;black&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;blue&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;blue&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;green&quot;</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Color</span> || (<span class="hljs-title class_">Color</span> = &#123;&#125;));<br><span class="hljs-keyword">var</span> currectColor = <span class="hljs-title class_">Color</span>.<span class="hljs-property">white</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(currectColor);<br></code></pre></td></tr></table></figure><p>这是一个匿名立即执行函数。可以看到枚举只是在一个对象中保存了几个变量而已。我们需要重点关注的是内部的赋值语句，以第一行为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;white&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;white&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样看可能会有点晕，我们将这个赋值语句分解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;white&quot;</span>] = <span class="hljs-number">0</span><br><span class="hljs-title class_">Color</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;white&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意在javascript中赋值语句会返回被赋值的值</strong>，所以上面两端代码是等价的，现在我们就可以知道currentColor为什么会输出0了。现在也可以很容易推断出以下代码的输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Color</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">//white</span><br></code></pre></td></tr></table></figure><h2 id="改变与枚举类型关联的数字"><a href="#改变与枚举类型关联的数字" class="headerlink" title="改变与枚举类型关联的数字"></a>改变与枚举类型关联的数字</h2><p>默认地，枚举类型的编号会从0开始，然后以1递增，就像上方的代码一样，但是我们也可以通过手动赋值来改变其值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    white, <span class="hljs-comment">//0</span><br>    black, <span class="hljs-comment">//1</span><br>    blue,  <span class="hljs-comment">//2</span><br>    green  <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    white = <span class="hljs-number">3</span><br>    black,<br>    blue,<br>    green<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Color</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) &#123;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;white&quot;</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;black&quot;</span>] = <span class="hljs-number">4</span>] = <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;blue&quot;</span>] = <span class="hljs-number">5</span>] = <span class="hljs-string">&quot;blue&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;green&quot;</span>] = <span class="hljs-number">6</span>] = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Color</span> || (<span class="hljs-title class_">Color</span> = &#123;&#125;));<br></code></pre></td></tr></table></figure><p>可以看到，现在编号从我们赋值的3开始递增。</p><h2 id="枚举是开放的-open-ended"><a href="#枚举是开放的-open-ended" class="headerlink" title="枚举是开放的(open ended)"></a>枚举是开放的(open ended)</h2><p>看以下代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    white,<br>    red,<br>&#125;<br><br><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    black = <span class="hljs-number">2</span>,<br>    blue<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码生成的js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Color</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) &#123;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;white&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;red&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Color</span> || (<span class="hljs-title class_">Color</span> = &#123;&#125;));<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) &#123;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;black&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;blue&quot;</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Color</span> || (<span class="hljs-title class_">Color</span> = &#123;&#125;));<br></code></pre></td></tr></table></figure><p>可以看到，枚举是可以通过重复声明的方式去扩充的。</p><h2 id="用字符串初始化枚举类型"><a href="#用字符串初始化枚举类型" class="headerlink" title="用字符串初始化枚举类型"></a>用字符串初始化枚举类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    <span class="hljs-title class_">White</span> = <span class="hljs-string">&#x27;white&#x27;</span>,<br>    <span class="hljs-title class_">Red</span> = <span class="hljs-string">&#x27;red&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码输出js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Color</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) &#123;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;White&quot;</span>] = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-title class_">Color</span>[<span class="hljs-string">&quot;Red&quot;</span>] = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Color</span> || (<span class="hljs-title class_">Color</span> = &#123;&#125;));<br></code></pre></td></tr></table></figure><p>可以看到，当我们用字符串去初始化枚举成员时，会直接给Color对象挂载该属性，而不会有编号。所以说明，当我们用字符串初始化某一个枚举成员时，后面所有的成员都必须用字符串初始化，否则ts会报错。因为这时无法确定后面成员的编号。</p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript高级特性-类</title>
    <link href="/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%B1%BB/"/>
    <url>/2022/02/23/typescript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先来看一个简单的typescript类的用法</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>    run (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is running`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> jack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">18</span>)<br>jack.<span class="hljs-title function_">run</span>() <span class="hljs-comment">//jack is running</span><br></code></pre></td></tr></table></figure><p>可以看到上面的例子中，类的用法基本和es6中的类没啥区别,我们需要重点注意点是继承和es6中没有提供的修饰符。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pat</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>    eat (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is eating`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Pat</span> &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>) &#123;<br>        <span class="hljs-comment">//必须调用super方法，否则typescript将报错</span><br>        <span class="hljs-variable language_">super</span>(name)<br>        <span class="hljs-comment">//添加子类独有的变量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color<br>    &#125;<br>    move (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is moving`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Bobi</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;Bobi&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>)<br><span class="hljs-title class_">Bobi</span>.<span class="hljs-title function_">eat</span>() <span class="hljs-comment">//Bobi is eating</span><br><span class="hljs-title class_">Bobi</span>.<span class="hljs-title function_">move</span>() <span class="hljs-comment">//Bobi is moving</span><br></code></pre></td></tr></table></figure><p>值得注意的点是，如果我们在用extends关键字继承了某一个类，那么我们必须在子类中用super(params)的形式调用父类的构造函数，否则typescript将报错。这样做可以保证所有需要挂载到子类实例的变量都挂载到实例中。除此之外也可以在子类构造函数中添加自己独有的变量。</p><p>除此之外，在子类中重复声明从父类中继承过来的属性和方法时，子类将会覆盖父类。</p><h2 id="静态变量-Statics"><a href="#静态变量-Statics" class="headerlink" title="静态变量(Statics)"></a>静态变量(Statics)</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pat</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>    eat (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is eating`</span>)<br>    &#125;<br>    <span class="hljs-keyword">static</span> staticMethod (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;it is a static method, can only accessed by the class itself&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Pat</span> &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color<br>    &#125;<br>    move (): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is moving`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Bobi</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;Bobi&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Tom</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pat</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>)<br><span class="hljs-title class_">Pat</span>.<span class="hljs-title function_">staticMethod</span>()<br><span class="hljs-title class_">Cat</span>.<span class="hljs-title function_">staticMethod</span>()<br><span class="hljs-title class_">Bobi</span>.<span class="hljs-title function_">staticMethod</span>() <span class="hljs-comment">//报错</span><br><span class="hljs-title class_">Tom</span>.<span class="hljs-title function_">staticMethod</span>() <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们在父类Pat中定义了一个静态方法staticMethod，运行之后可以发现<strong>只能在父类或者子类本身才可以成功访问该方法，否则将报错，还有一个可以访问静态属性或者方法的地方就是类内部，请看以下代码</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Something</span> &#123;<br>    <span class="hljs-keyword">static</span> instances = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Something</span>.<span class="hljs-property">instances</span>++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Something</span>();<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Something</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Something</span>.<span class="hljs-property">instances</span>); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>typescript提供了三种修饰符，分别是<strong>public,protected,private</strong>，分别的访问权限如下表所示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/908d5d21b22640d586e23cdd5556ac7d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>当没有使用任何修饰符是，变量权限默认为public。</p><p><strong>值得注意的点时，在生成的js代码中，无论我们在什么地方访问protected或者private变量都可以正常运行，但是typescript会给出一个编译时错误。以确保让我们正确使用这些修饰符</strong>请看以下代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// EFFECT ON INSTANCES</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FooBase</span>();<br>foo.<span class="hljs-property">x</span>; <span class="hljs-comment">// okay</span><br>foo.<span class="hljs-property">y</span>; <span class="hljs-comment">// ERROR : private</span><br>foo.<span class="hljs-property">z</span>; <span class="hljs-comment">// ERROR : protected</span><br><br><span class="hljs-comment">// EFFECT ON CHILD CLASSES</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FooBase</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>; <span class="hljs-comment">// okay</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>; <span class="hljs-comment">// ERROR: private</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span>; <span class="hljs-comment">// okay</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>部分代码示例，以及修饰符表格来自 TypeScript Deep Dive Basarat AliSyed著</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式系列篇：混入模式</title>
    <link href="/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E6%B7%B7%E5%85%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E6%B7%B7%E5%85%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在js中，我们可以将Mixin看作是一种通过扩展收集功能的方式。它非常适合js的对象原型，我们可以从不止一个Mixin中分享功能来提升代码的复用性，降低重复度</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span> (model = <span class="hljs-literal">null</span>, color = <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color    <br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CarMove</span> () &#123;&#125;<br><br><span class="hljs-title class_">CarMove</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;car is running&#x27;</span>)<br>&#125;<br><br><span class="hljs-title class_">CarMove</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">stop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;car has stoped&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的代码中，我们分别把Car的属性和Car的方法提到了两个构造函数中，真实开发中当然不建议这么做，这么写只是为了展示Mixin模式的用法。</p><p>现在要做的就是编写Mixin函数了，请看以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixin</span> (origin, source, ...rest) &#123;<br>    <span class="hljs-keyword">const</span> restLen = rest.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (restLen) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; restLen; i++) &#123;<br>            origin.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[rest[i]] = source.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[rest[i]]<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> method <span class="hljs-keyword">in</span> source.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(origin.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, method)) &#123;<br>                origin.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method] = source.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mixin函数的职责是将source对象中的方法混入到origin对象中去。有同学会想直接用Object.assign不就可以了，但是该函数与Object.assign有两点不同。</p><p>第一点是该函数可以指定需要混入source对象中的哪些属性，这在第一个判断语句中体现。如果用了3个或多个参数调用，表明指定了属性名，则会只混入指定的属性，剩下的不做处理。</p><p>第二点是优先级。在Object.assign中，如果源对象和目标对象同时含有某个属性，则源对象中的属性会覆盖目标对象中的属性，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> person2 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(person1, person2)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1)<br></code></pre></td></tr></table></figure><p>以上代码的输出结果如图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3726b28f90e24c0291fc50ac503e75ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以看到，person2的name属性覆盖了person1的name属性，而在我们写的mixin函数中，源对象属性的优先级更高，这点可以从函数中第二个if语句看出来。</p><p>测试mixin函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mixin</span>(<span class="hljs-title class_">Car</span>, <span class="hljs-title class_">CarMove</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88be7291295f4318967240736fa12778~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>指定属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mixin</span>(<span class="hljs-title class_">Car</span>, <span class="hljs-title class_">CarMove</span>, <span class="hljs-string">&#x27;run&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dfb5dd1856847e48dd25f11b8c5a8f0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以看出mixin函数运行正常</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Mixin模式有助于提高函数复用，减少系统代码的重复度。当一个程序在各个对象中共享属性和行为时，我们可以考虑使用Mixin模式。但Mixin模式也有自己的缺点，有些人认为将功能注入对象原型中的操作会导致原型污染和函数起源方面的不确定性等方面的问题，所以在使用时需要衡量利弊来做出选择。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式系列篇：命令模式</title>
    <link href="/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是命令模式"><a href="#什么是命令模式" class="headerlink" title="什么是命令模式"></a>什么是命令模式</h1><p>命令模式是指将方法的调用等操作封装到单一的对象中，将调用操作的对象与知道如何实现该操作的对象解耦，为系统提供更大的灵活性。</p><p>上面的描述很绕口，我们不妨来看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> car = &#123;<br>    <span class="hljs-attr">getInfo</span>: <span class="hljs-function">(<span class="hljs-params">model, id</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`the information for <span class="hljs-subst">$&#123;model&#125;</span> width ID:<span class="hljs-subst">$&#123;id&#125;</span> is foo`</span>)<br>    &#125;,<br>    <span class="hljs-attr">buy</span>: <span class="hljs-function">(<span class="hljs-params">model, id</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`you have buy the <span class="hljs-subst">$&#123;model&#125;</span> with ID:<span class="hljs-subst">$&#123;id&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码没有任何问题。但是，想想如果car里的某个方法改变了会怎么样。这可能会要求我们将程序中所有调用这些方法的地方都改一遍。这就形成了一个紧密耦合，违反了OOP原则中的松耦合原则。</p><p>这时候，我们就可以用到命令模式了。我们可以在car中再编写一个方法，这个方法接受car中的任意方法名和任何需要用到的参数，调用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car.<span class="hljs-title function_">execute</span>(<span class="hljs-string">&#x27;getInfo&#x27;</span>, <span class="hljs-string">&#x27;Tesla&#x27;</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>一般，命令模式都会包含类似的执行操作(execute, run)，我们可以将其看成是一个对car对象的命令，命令car执行某个函数。</p><p>现在实现一下execute方法，非常简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> car = &#123;<br>    <span class="hljs-attr">getInfo</span>: <span class="hljs-function">(<span class="hljs-params">model, id</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`the information for <span class="hljs-subst">$&#123;model&#125;</span> width ID:<span class="hljs-subst">$&#123;id&#125;</span> is foo`</span>)<br>    &#125;,<br>    <span class="hljs-attr">buy</span>: <span class="hljs-function">(<span class="hljs-params">model, id</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`you have buy the <span class="hljs-subst">$&#123;model&#125;</span> with ID:<span class="hljs-subst">$&#123;id&#125;</span>`</span>)<br>    &#125;,<br>    <span class="hljs-attr">execute</span>: <span class="hljs-function">(<span class="hljs-params">methodName, ...rest</span>) =&gt;</span> &#123;<br>        car[methodName] &amp;&amp; car[methodName].<span class="hljs-title function_">apply</span>(car, rest)<br>    &#125;<br>&#125;<br>car.<span class="hljs-title function_">execute</span>(<span class="hljs-string">&#x27;getInfo&#x27;</span>, <span class="hljs-string">&#x27;Tesla&#x27;</span>, <span class="hljs-number">1</span>)<br>car.<span class="hljs-title function_">execute</span>(<span class="hljs-string">&#x27;buy&#x27;</span>, <span class="hljs-string">&#x27;Honda&#x27;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>执行上面的代码，在控制台看到如下输出</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/499564ea4776467a84d518447372b8f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>说明execute方法运行正常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>命令模式通过暴露一个统一的执行接口，来提高系统的可维护性和灵活性。我们也可以将其与模块模式相结合，隐藏其余所有的方法，只对外暴露一个公用接口。在多人协作的项目中相信可以有效减少沟通成本，使得代码更加统一，简洁。</p><p>下面给出一个简单的模块模式的实现，大家可以试一下如何将其与命令模式结合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//私有变量</span><br>    <span class="hljs-keyword">let</span> myPrivate = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">//私有方法</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">privateMethod</span> = (<span class="hljs-params">foo</span>) =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">publicFunction</span>: <span class="hljs-function">(<span class="hljs-params">bar</span>) =&gt;</span> &#123;<br>            myPrivate++<br>            <span class="hljs-title function_">privateMethod</span>(bar)<br>        &#125;<br>    &#125;<br>&#125;)()<br><br>myModule.<span class="hljs-title function_">publicFunction</span>(<span class="hljs-string">&#x27;baz&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式系列篇：发布-订阅者模式</title>
    <link href="/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="与观察者-observer-模式的不同"><a href="#与观察者-observer-模式的不同" class="headerlink" title="与观察者(observer)模式的不同"></a>与观察者(observer)模式的不同</h1><p>观察者模式要求希望接受到通知的观察者必须订阅内容改变的事件。<br/></p><p>而发布订阅者模式使用了一个主题/事件通道。该通道介于事件的发布者和希望接受该事件通知的订阅者之间。该模式允许我们自定义事件，事件也可以传递自定义参数，参数是需要通知给订阅者的数据。其目的是避免发布者和订阅者之间产生依赖关系。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0285fc6fb540a5b6077c8fc4d83adb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>与观察者模式不同，发布订阅者模式允许任何订阅者注册和接受发布者发出的通知，而无需依附与某个目标对象上。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pubsub = &#123;&#125;;<br><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">q</span>) &#123;<br>    <span class="hljs-keyword">const</span> topics = []<br>    <span class="hljs-keyword">let</span> subId = -<span class="hljs-number">1</span><br><br>    q.<span class="hljs-property">publish</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">topic, args</span>) &#123;<br>        <span class="hljs-comment">//该事件没有订阅者直接返回</span><br>        <span class="hljs-keyword">if</span> (!topics[topic]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">//获取订阅者</span><br>        <span class="hljs-keyword">const</span> subscribers = topics[topic]<br>        <span class="hljs-keyword">let</span> len = subscribers ? subscribers.<span class="hljs-property">length</span> : <span class="hljs-number">0</span><br>        <span class="hljs-comment">//遍历触发所有该事件订阅者的注册函数</span><br>        <span class="hljs-keyword">while</span> (len--) &#123;<br>            subscribers[len].<span class="hljs-title function_">func</span>(topic, args)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>    <span class="hljs-comment">//订阅事件，只需要把将其加入到topics对象就可以</span><br>    q.<span class="hljs-property">subscribe</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">topic, func</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!topics[topic]) &#123;<br>            topics[topic] = []<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> token = (++subId).<span class="hljs-title function_">toString</span>()<br><br>        topics[topic].<span class="hljs-title function_">push</span>(&#123;<br>            token,<br>            func<br>        &#125;)<br>        <span class="hljs-keyword">return</span> token<br>    &#125;<br>&#125;)(pubsub)<br></code></pre></td></tr></table></figure><p>上面的代码是一个立即执行函数，我们可以把pubsub看作是之前提到的<strong>主题/事件通道</strong>。发布者可以往这个通道发布事件，订阅者可以在这个通道订阅事件。具体的调用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//简单的消息记录其记录所有通过订阅者接收到的主题(topic)和数据</span><br><span class="hljs-keyword">const</span> messageLogger = <span class="hljs-keyword">function</span> (<span class="hljs-params">topics, data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Logging<span class="hljs-subst">$&#123;topics&#125;</span>:<span class="hljs-subst">$&#123;data&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">//订阅者监听订阅的topic,一旦该topic广播一个通知，订阅者就调用回调函数</span><br><span class="hljs-keyword">const</span> subscription = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;inbox/newMessage&quot;</span>, messageLogger)<br><span class="hljs-keyword">const</span> subscription1 = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;inbox/newMessage&quot;</span>, messageLogger)<br><br><span class="hljs-comment">//发布者负责发布程序感兴趣的topic或通知，例如</span><br><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&quot;inbox/newMessage&quot;</span>, <span class="hljs-string">&quot;hello word&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上代码，即可在控制台看到输出</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91fe095196bf4713b06aee3f17d7b28c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们可以看到，上面的代码实现中，并没有类似与观察者模式的具体的<strong>目标对象(Subject)<strong>，也没有依附在目标对象上的观察者。所有的发布者和订阅者，都只是在</strong>主题/事件通道</strong>进行发布和订阅。发布者和订阅者并不关心彼此，这也是该模式与观察者模式的一个明显的区别。</p><p>具体的观察者模式的介绍，可以参考我上一篇文章:   <a href="https://juejin.cn/post/7022934151665811463">js设计模式系列篇：观察者模式</a></p><p><em>以上实例代码均来自 JavaScript设计模式 Addy Osmani著 徐涛译</em></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式系列篇：观察者模式</title>
    <link href="/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/23/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%AF%87%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者(observer)模式是js中应用很广泛的一种设计模式。它主要是通过在一个<strong>目标对象上维护一系列依附于它的观察者(observer)对象来实现</strong>，在目标对象上有任何状态改变时，会自动地通知给观察者。<br/></p><p>先来看一个简单的实现</p><h3 id="观察者的实现"><a href="#观察者的实现" class="headerlink" title="观察者的实现"></a>观察者的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">constructor</span> () &#123;&#125;<br><br>    update (context) &#123;<br>        <span class="hljs-comment">//观察者收到通知后触发的函数</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`recieved data is <span class="hljs-subst">$&#123;context&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是简单的观察者的定义。<strong>目标对象</strong>在需要的时候可以触发update函数以实现对<strong>观察者</strong>的通知。</p><h3 id="观察者列表"><a href="#观察者列表" class="headerlink" title="观察者列表"></a>观察者列表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//观察者列表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverList</span> &#123;<br>    <span class="hljs-title function_">constructor</span> () &#123;<br>        <span class="hljs-comment">//用数组去保存观察者</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = []<br>    &#125;<br>    <span class="hljs-comment">//添加一个观察者</span><br>    add (observer) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(observer)<br>    &#125;<br>    <span class="hljs-comment">//获取观察者的个数</span><br>    count () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span><br>    &#125;<br>    <span class="hljs-comment">//移除观察者</span><br>    remove (observer) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== observer)<br>    &#125;<br>    <span class="hljs-comment">//获取观察者</span><br>    getIndexAt (index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span> &amp;&amp; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">count</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[index]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是<strong>观察者列表</strong>，list数组中保存的是一个个Observer类的实例，即<strong>观察者</strong>。我们可以用该类，对依附在某一个<strong>目标对象</strong>上的<strong>观察者</strong>进行统一的管理和维护。</p><h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//目标对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-title function_">constructor</span> () &#123;<br>        <span class="hljs-comment">//观察者依附于目标对象上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverList</span>()<br>    &#125;<br>    <span class="hljs-comment">//在目标对象上新增一个观察者</span><br>    addObserver (observer) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">add</span>(observer)<br>    &#125;<br>    <span class="hljs-comment">//从目标对象上移除观察者</span><br>    removeObserver (observer) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">remove</span>(observer)<br>    &#125;<br>    <span class="hljs-comment">//通知观察者</span><br>    notify (context) &#123;<br>        <span class="hljs-keyword">const</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">count</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">getIndexAt</span>(i).<span class="hljs-title function_">update</span>(context)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上代码可以看到，<strong>目标对象</strong>实例上挂载了一个ObserverList实例对象。用来保存依附在该<strong>目标对象</strong>上的所有观察者。当<strong>目标对象</strong>状态有变化时，可以通过notify函数，遍历触发所有<strong>观察者</strong>上的update函数，以此来实现对<strong>所有观察者的通知</strong></p><p>代码实现完毕，我们现在来试验一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建观察者</span><br><span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()<br><span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()<br><span class="hljs-comment">//创建一个目标对象</span><br><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>()<br><span class="hljs-comment">//将两个观察者加入到目标对象上的观察者列表中</span><br>subject.<span class="hljs-title function_">addObserver</span>(observer1)<br>subject.<span class="hljs-title function_">addObserver</span>(observer2)<br><span class="hljs-comment">//通知观察者</span><br>subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;hello my observer&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行以上代码，可以在控制台看到输出了两次，如下图</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ee61e051d8486c8bf5ef598b2b8303~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这就说明<strong>目标对象</strong>成功通知到了依附在自身的两个<strong>观察者</strong>。</p><p>我们来试验一下移除观察者功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建观察者</span><br><span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()<br><span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()<br><span class="hljs-comment">//创建一个目标对象</span><br><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>()<br><span class="hljs-comment">//将两个观察者加入到目标对象上的观察者列表中</span><br>subject.<span class="hljs-title function_">addObserver</span>(observer1)<br>subject.<span class="hljs-title function_">addObserver</span>(observer2)<br><span class="hljs-comment">//移除观察者</span><br>subject.<span class="hljs-title function_">removeObserver</span>(observer1)<br><span class="hljs-comment">//通知观察者</span><br>subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;hello my observer&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上代码中，<strong>目标对象</strong>在通知<strong>观察者</strong>之前移除了其中一个观察者，所以我们可以看到控制台只打印了一次消息</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307bf98233e04feebeac4ab5ebb0c799~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="小案例-画彩虹"><a href="#小案例-画彩虹" class="headerlink" title="小案例-画彩虹"></a>小案例-画彩虹</h2><p>在了解完具体的观察者模式之后，我们来实现一个小案例。最终的效果如下图</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a36ab8a63fb347f982420a6b429f4e6a~tplv-k3u1fbpfcp-watermark.image" alt="20211025-165418.gif"></p><p>实现出来的效果是，按住下方的小黑圈左右拖动，上方的7个彩虹颜色的div的宽度也会相应地放大和缩小。</p><p>在本案例中，小黑圈就是<strong>目标对象</strong>，7个彩虹颜色地div就是<strong>依附在该小黑圈中的观察者</strong>。当小黑圈的坐标发生变化时，需要通知给这些观察者，告诉他们需要改变自身的宽度。</p><p>下面来看具体的实现</p><h3 id="html结构"><a href="#html结构" class="headerlink" title="html结构"></a>html结构</h3><p>样式部分省略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(255,0,0);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(255,165,0);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(255,255,0);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(0,255,0);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(0,127,255);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(0,0,255);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rainbow&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(139,0,255);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;progress-bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="定义observer"><a href="#定义observer" class="headerlink" title="定义observer"></a>定义observer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//item是需要充当观察者的7个div元素</span><br>    <span class="hljs-title function_">constructor</span> (item) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = item<br>    &#125;<br>    <span class="hljs-comment">//观察者收到通知时，更新自身的width</span><br>    update (data) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = data + <span class="hljs-string">&#x27;px&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义观察者列表"><a href="#定义观察者列表" class="headerlink" title="定义观察者列表"></a>定义观察者列表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//观察者列表，跟之前实现的差不多</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverList</span> &#123;<br>    <span class="hljs-title function_">constructor</span> () &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = []<br>    &#125;<br><br>    add (observers) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(observers)<br>    &#125;<br><br>    count () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span><br>    &#125;<br><br>    getIndexAt (index) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[index]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="目标对象-1"><a href="#目标对象-1" class="headerlink" title="目标对象"></a>目标对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//目标对象的实现也基本上一样</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (subject) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverList</span>()<br>    &#125;<br><br>    addObserver (observers) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">add</span>(observers)<br>    &#125;<br><br>    notify (data) &#123;<br>        <span class="hljs-keyword">const</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">count</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">getIndexAt</span>(i).<span class="hljs-title function_">update</span>(data)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们要做的就是，获取7个div元素充当观察者，并添加到我们实例化的目标对象上。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rainbows = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.rainbow&#x27;</span>)<br><span class="hljs-keyword">const</span> bar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;progress-bar&#x27;</span>)<br><span class="hljs-keyword">const</span> barSubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>()<br>rainbows.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(item)<br>    barSubject.<span class="hljs-title function_">addObserver</span>(observer)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们获取了7个div对象，并遍历用每一个div实例化一个Observer，并添加到<strong>目标对象</strong>上。</p><p>之后要做的就是实现<strong>目标对象</strong>的拖放，并在拖放过程中通知<strong>观察者</strong>即可，实现拖放的部分省略，这里给出通知给观察者的部分，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br><br>    event = event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br><br>    <span class="hljs-keyword">const</span> sl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollLeft</span>;<br><br>    <span class="hljs-keyword">const</span> left = event.<span class="hljs-property">clientX</span> - ol;<br>    box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = left + sl + <span class="hljs-string">&quot;px&quot;</span>;<br>    <span class="hljs-comment">//通知观察者</span><br>    barSubject.<span class="hljs-title function_">notify</span>(left + sl)<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，案例就完成了。希望对大家有所帮助。有不对的地方欢迎大佬们指正。</p><p><strong>注意：观察者模式和大家熟知的发布/订阅者模式是有区别的，我会在下一篇文章中介绍</strong></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5分钟入门webpack</title>
    <link href="/2022/02/21/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8webpack/"/>
    <url>/2022/02/21/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8webpack/</url>
    
    <content type="html"><![CDATA[<p>要学习webpack之前，我觉得有必要了解一下模块化的概念。<br/></p><h1 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h1><p>在过去很长的一段时间里，javascript并没有模块这个概念。如果我们要在页面中引用其他的js文件，只能通过script标签将其一个个插入到页面中。这样做有很多的缺陷，比如无法在页面中清晰地看出这些js文件之间的依赖关系。而且在script标签中顶层作用域即全局作用域，这会造成全局作用域污染，在一个团队协作的大型项目中，非常容易引发命名冲突等问题。<br/><br>模块化解决了上述几个问题，在一个模块化的js文件中，可以通过导入导出语句很清晰地看出依赖关系，而且每个模块的作用域都是独立的，不会污染全局，彼此也不会有命名冲突，极大地提升了一个大型项目的开发效率，可维护性。<br>社区也诞生了几种模块化规范，如<strong>CommonJs,AMD,UMD还有与ES6一起发布的ES6 Module等</strong>大家可以自行了解一下。<br/></p><h1 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h1><p><strong>在了解过什么是模块之后，简单地讲，webpack就是用来实现模块化javascript的打包工具</strong><br/><br>在webpack中，每个文件都是单独的一个模块，之后通过用loader转换，通过plugin注入钩子，最终输出一个由多个模块组成的文件。我们只需要在html文件中引用最终输出的文件即可。</p><h2 id="看一个简单的例子。"><a href="#看一个简单的例子。" class="headerlink" title="看一个简单的例子。"></a>看一个简单的例子。</h2><p>以下是目录结构</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b70ea4042b474cb89afa04a7013a7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="webpack-config-js文件"><a href="#webpack-config-js文件" class="headerlink" title="webpack.config.js文件"></a>webpack.config.js文件</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./main.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;/dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该文件是webpack的配置文件，webpack会从该文件读取配置<br/><br><strong>entry:</strong> 用来指明整个项目的入口文件，webpack会从该文件开始，递归地解析出所有的模块<br/><br><strong>output.path:</strong> 输出文件的存放路径，必须是绝对路径</br><br><strong>output.filename:</strong> 指定最终输出的打包好的文件名字</br></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span><br><br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><h3 id="foo-js"><a href="#foo-js" class="headerlink" title="foo.js"></a>foo.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> () &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello webpack&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>main.js入口文件中引用了foo.js文件，并执行了foo函数，函数会在页面输出 hello webpack。<br/><br>我们在终端执行 <strong>webpack</strong> 命令，可以看到项目中多出了一个dist目录，里面有打包生成的bundle.js文件</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca73afe60bc54e6ba3fd7c1974a4ad48~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这就是webpack打包后生成的文件，我们在index.html文件中用script标签引入该文件，到开浏览器就可以看到效果。如图</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2919dbe232b84292a7a5814fe2fd89e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>至此，我们已经利用webpack实现了一个简单的模块化项目。</p><h1 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h1><p>webpack原生不支持解析任何非javascript的文件。要解析非javascript文件就需要用到loader。比如在上面的例子中，我们要给文案加点样式，我们就需要写一个css文件。为了加载这个css文件，就需要loader出场了。<br/><br>修改webpack.config.js文件如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./main.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;/dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>新增字段：</strong><br/><br><strong>module:</strong> 配置处理模块的规则<br/><br><strong>rules:</strong> rules配置模块的读取和解析规则，通常用来配置loader。具体用法是利用test,include,exclude三个配置项来指定loader要应用规则的文件。然后用use字段来指定需要用到的loader。需要注意的是，loader是根据use数组倒序执行的。在上面的例子中，所有的css文件都会先交给css-loader处理，处理完之后再交给style-loader处理。</p><p>我们在项目中创建一个css文件，然后再main.js文件中引入，如下</p><h2 id="main-css"><a href="#main-css" class="headerlink" title="main.css"></a>main.css</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main-js-1"><a href="#main-js-1" class="headerlink" title="main.js"></a>main.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./main.css&#x27;</span><br><br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><p>重新打包，打开浏览器，即可看到字体变成了红色</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ecab2dd91942f58f83adf4a28281ef~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这就是loader的作用。每种文件类型都可以在社区找到对应的loader，比如vue-loader,ts-loader等。大家可以自行了解。</p><h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>plugin用于扩展webpack的功能。通过在构建流程注入钩子来实现，极大地提升了webpack的灵活性。<br/><br>以上面的配置为例，我们在项目中引入一个css文件，并用css-loader和style-loader来加载。最终打包生成的还是只有一个js文件。这是因为所有的样式都以字符串的形式合并到了js文件中。在实际开发中，这很不利于维护和优化。所以我们想要将css文件打包到一个单独文件，再单独引入这个css文件。这个就需要用plugin来实现。修改webpack.config.js文件如下</p><h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./main.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;/dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-comment">//这里用插件的loader替换style-loader</span><br>                <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-comment">//提取出来的css文件名称</span><br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">`[name]@[hash].css`</span><br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，plugins配置项接受一个数组。数组中是各个plugin的实例。plugin的具体配置需要自己去查询。<br/><br>配置完毕，再次运行webpack命令打包项目，即可看到dist目录下多出了一个css文件，如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06a09257da3c4dc1a7663efe5cb1e87a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>名字是我们配置好的css源文件名和文件的哈希值。<br/><br>接下来我们直接在index.html中引入该文件即可。</p><h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><p>通过以上的配置，我们可以让webpack正常运行起来，实现打包。但是在实际开发中，每次修改代码都需要打包一次，会让我们的开发效率大大降低。devServer会启动一个http服务器用于服务网页请求，同时会帮助启动webpack,并在监听到文件内容有变化时，通过websocket协议自动刷新页面。</p><p>第一次发文章，有不对的地方欢迎大家指正</p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
